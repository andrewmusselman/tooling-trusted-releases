#!/usr/bin/env -S uv run --script

# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "aiohttp",
#     "cyclopts",
#     "filelock",
#     "platformdirs",
#     "pyjwt",
#     "pytest>=8.4.1",
#     "strictyaml",
# ]
# [tool.uv]
# exclude-newer = "2025-07-04T19:04:51Z"
# ///

# Guide to contributors:
#
# - Use "import A", not "from A import ...", except for "from typing"
# - Group constants, types, and functions, then order alphabetically
# - Name functions in object oriented style, noun first and verb last
# - Do not use an underscore at the start of any interface names
# - Use list, | None, etc. in types
# - Use match and case, and the walrus operator
# - Never use "case _" with exhaustive types
# - Keep functions very short, and avoid indentation
# - Always group binary subexpressions in boolean expressions
# - Do not add any comments


from __future__ import annotations

import asyncio
import contextlib
import datetime
import json
import logging
import os
import pathlib
import re
import subprocess
import sys
import tempfile
from typing import TYPE_CHECKING, Annotated, Any, Literal

import aiohttp  # type: ignore[import-not-found]
import cyclopts  # type: ignore[import-not-found]
import filelock  # type: ignore[import-not-found]
import jwt  # type: ignore[import-not-found]
import platformdirs  # type: ignore[import-not-found]
import pytest  # type: ignore[import-not-found]
import strictyaml  # type: ignore[import-not-found]

if TYPE_CHECKING:
    from collections.abc import Generator

APP: cyclopts.App = cyclopts.App()
CHECKS: cyclopts.App = cyclopts.App(name="checks", help="Check result operations.")
CONFIG: cyclopts.App = cyclopts.App(name="config", help="Configuration operations.")
DEV: cyclopts.App = cyclopts.App(name="dev", help="Developer operations.")
JWT: cyclopts.App = cyclopts.App(name="jwt", help="JWT operations.")
LOGGER = logging.getLogger(__name__)
RELEASE: cyclopts.App = cyclopts.App(name="release", help="Release operations.")
YAML_DEFAULTS: dict[str, Any] = {"asf": {}, "atr": {}, "tokens": {}}
YAML_SCHEMA: strictyaml.Map = strictyaml.Map(
    {
        strictyaml.Optional("atr"): strictyaml.Map({strictyaml.Optional("host"): strictyaml.Str()}),
        strictyaml.Optional("asf"): strictyaml.Map({strictyaml.Optional("uid"): strictyaml.Str()}),
        strictyaml.Optional("tokens"): strictyaml.Map(
            {
                strictyaml.Optional("pat"): strictyaml.Str(),
                strictyaml.Optional("jwt"): strictyaml.Str(),
            }
        ),
    }
)

APP.command(CHECKS)
APP.command(CONFIG)
APP.command(DEV)
APP.command(JWT)
APP.command(RELEASE)


@CHECKS.command(name="status", help="Get check status for a release revision.")
def app_checks_status(project: str, version: str, revision: str) -> None:
    with config_lock() as config:
        jwt_value = config_get(config, ["tokens", "jwt"])

    if jwt_value is None:
        LOGGER.error("No JWT stored in configuration.")
        sys.exit(1)

    host = config.get("atr", {}).get("host", "release-test.apache.org")
    url = f"https://{host}/api/checks/{project}/{version}/{revision}"

    verify_ssl = not host.startswith("127.0.0.1")
    results = asyncio.run(web_get(url, jwt_value, verify_ssl))

    checks_display(results)


@CONFIG.command(name="file", help="Display the configuration file contents.")
def app_config_file() -> None:
    path = config_path()
    if not path.exists():
        LOGGER.error("No configuration file found.")
        sys.exit(1)

    with path.open("r", encoding="utf-8") as fh:
        for chunk in fh:
            print(chunk, end="")


@CONFIG.command(name="path", help="Show the configuration file path.")
def app_config_path() -> None:
    print(config_path())


@DEV.command(name="lock", help="Regenerate uv lockfile.")
def app_dev_lock() -> None:
    subprocess.check_call(["uv", "lock", "--script", str(pathlib.Path(__file__))])


@DEV.command(name="stamp", help="Update date stamp in header.")
def app_dev_stamp() -> None:
    path = pathlib.Path(__file__)
    text = path.read_text()
    ts = datetime.datetime.now(datetime.UTC).strftime("%Y-%m-%dT%H:%M:%SZ")
    new_text = re.sub(r"\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z", ts, text)
    if text == new_text:
        LOGGER.info("No stamp updated.")
        return
    path.write_text(new_text, "utf-8")
    LOGGER.info(f"Stamp updated to {ts}.")


@APP.command(name="drop", help="Remove a configuration key using dot notation.")
def app_drop(path: str) -> None:
    parts = path.split(".")
    if not parts:
        LOGGER.error("Not a valid configuration key")
        sys.exit(1)

    with config_lock(write=True) as config:
        present, _ = config_walk(config, parts, "drop")
        if not present:
            LOGGER.error(f"Could not find {path} in the configuration file")
            sys.exit(1)

    LOGGER.info(f"Removed {path}.")


@JWT.command(name="dump", help="Show decoded JWT payload from stored config.")
def app_jwt_dump() -> None:
    with config_lock() as config:
        jwt_value = config_get(config, ["tokens", "jwt"])

    if jwt_value is None:
        LOGGER.error("No JWT stored in configuration.")
        sys.exit(1)

    header = jwt.get_unverified_header(jwt_value)
    if header != {"alg": "HS256", "typ": "JWT"}:
        LOGGER.error("Invalid JWT header.")
        sys.exit(1)

    try:
        payload = jwt.decode(jwt_value, options={"verify_signature": False})
    except jwt.PyJWTError as e:
        LOGGER.error(f"Failed to decode JWT: {e}")
        sys.exit(1)

    print(json.dumps(payload, indent=None))


@JWT.command(name="info", help="Show JWT payload in human-readable form.")
def app_jwt_info() -> None:
    with config_lock() as config:
        jwt_value = config_get(config, ["tokens", "jwt"])

    if jwt_value is None:
        LOGGER.error("No JWT stored in configuration.")
        sys.exit(1)

    try:
        payload = jwt.decode(jwt_value, options={"verify_signature": False})
    except jwt.PyJWTError as e:
        LOGGER.error(f"Failed to decode JWT: {e}")
        sys.exit(1)

    lines: list[str] = []
    for key, val in payload.items():
        if key in ("exp", "iat", "nbf"):
            val = timestamp_format(val)
        lines.append(f"{key.title()}: {val}")

    print("\n".join(lines))


@JWT.command(name="refresh", help="Fetch a JWT using the stored PAT and store it in config.")
def app_jwt_refresh(asf_uid: str | None = None) -> None:
    with config_lock() as config:
        pat_value = config_get(config, ["tokens", "pat"])

    if pat_value is None:
        LOGGER.error("No Personal Access Token stored.")
        sys.exit(1)

    host = config.get("atr", {}).get("host", "release-test.apache.org")
    url = f"https://{host}/api/jwt"

    if asf_uid is None:
        asf_uid = config.get("asf", {}).get("uid")

    if asf_uid is None:
        LOGGER.error("No ASF UID provided and asf.uid not configured.")
        sys.exit(1)

    verify_ssl = not host.startswith("127.0.0.1")
    jwt_token = asyncio.run(web_fetch(url, asf_uid, pat_value, verify_ssl))

    with config_lock(write=True) as config:
        config_set(config, ["tokens", "jwt"], jwt_token)

    print(jwt_token)


@JWT.command(name="show", help="Show stored JWT token.")
def app_jwt_show() -> None:
    return app_show("tokens.jwt")


@RELEASE.command(name="list", help="List releases for PROJECT.")
def app_release_list(project: str) -> None:
    with config_lock() as config:
        host = config.get("atr", {}).get("host", "release-test.apache.org")

    url = f"https://{host}/api/releases/{project}"
    verify_ssl = not host.startswith("127.0.0.1")

    result = asyncio.run(web_get_public(url, verify_ssl))
    releases_display(result)


@RELEASE.command(name="start", help="Start a release.")
def app_release_start(project: str, version: str) -> None:
    with config_lock() as config:
        jwt_value = config_get(config, ["tokens", "jwt"])

    if jwt_value is None:
        LOGGER.error("No JWT stored in configuration.")
        sys.exit(1)

    host = config.get("atr", {}).get("host", "release-test.apache.org")
    url = f"https://{host}/api/releases/create"

    payload: dict[str, str] = {"project_name": project, "version": version}

    verify_ssl = not host.startswith("127.0.0.1")
    result = asyncio.run(web_post(url, payload, jwt_value, verify_ssl))
    print(result)


@APP.command(name="set", help="Set a configuration value using dot notation.")
def app_set(path: str, value: str) -> None:
    parts = path.split(".")
    if not parts:
        LOGGER.error("Not a valid configuration key.")
        sys.exit(1)

    with config_lock(write=True) as config:
        config_set(config, path.split("."), value)

    LOGGER.info(f"Set {path} to {value}.")


@APP.command(name="show", help="Show a configuration value using dot notation.")
def app_show(path: str) -> None:
    parts = path.split(".")
    if not parts:
        LOGGER.error("Not a valid configuration key.")
        sys.exit(1)

    with config_lock() as config:
        value = config_get(config, parts)

    if value is None:
        LOGGER.error(f"Could not find {path} in the configuration file.")
        sys.exit(1)

    print(value)


@APP.command(name="test", help="Run tests.")
def app_test(q: Annotated[bool, cyclopts.Parameter(alias="-q")] = False, *pytest_args: str) -> None:
    cwd = os.getcwd()
    with tempfile.TemporaryDirectory() as td:
        p = pathlib.Path(td, "atr_api_client.py")
        p.write_bytes(pathlib.Path(__file__).read_bytes())
        os.chdir(td)
        prev = os.environ.get("ATR_CLIENT_CONFIG_PATH")
        os.environ["ATR_CLIENT_CONFIG_PATH"] = str(pathlib.Path(td, "atr_test.yaml"))
        try:
            args = (["-q"] if q else []) + list(pytest_args) + [str(p)]
            sys.exit(pytest.main(args))
        finally:
            if prev is None:
                os.environ.pop("ATR_CLIENT_CONFIG_PATH", None)
            else:
                os.environ["ATR_CLIENT_CONFIG_PATH"] = prev
            os.chdir(cwd)


def checks_display(results: list[dict[str, Any]]) -> None:
    if not results:
        print("No check results found for this revision.")
        return

    by_status = {}
    for result in results:
        status = result["status"]
        by_status.setdefault(status, []).append(result)

    print(f"Total checks: {len(results)}")
    for status, checks in by_status.items():
        print(f"  {status}: {len(checks)}")

    for status in ["FAILURE", "EXCEPTION", "WARNING"]:
        if status in by_status:
            print(f"\n{status}:")
            for check in by_status[status]:
                print(f"  - {check['checker']}: {check['message']}")


def config_drop(config: dict[str, Any], parts: list[str]) -> None:
    config_walk(config, parts, "drop")


def config_get(config: dict[str, Any], parts: list[str]) -> Any | None:
    return config_walk(config, parts, "get")[1]


@contextlib.contextmanager
def config_lock(write: bool = False) -> Generator[dict[str, Any]]:
    lock = filelock.FileLock(str(config_path()) + ".lock")
    with lock:
        config = config_read()
        yield config
        if write is True:
            config_write(config)


def config_path() -> pathlib.Path:
    if env := os.getenv("ATR_CLIENT_CONFIG_PATH"):
        return pathlib.Path(env).expanduser()
    return platformdirs.user_config_path("atr", appauthor="ASF") / "atr.yaml"


def config_read() -> dict[str, Any]:
    config_file = config_path()
    if config_file.exists():
        try:
            return strictyaml.load(config_file.read_text(), YAML_SCHEMA).data
        except strictyaml.YAMLValidationError as e:
            raise RuntimeError(f"Invalid atr.yaml: {e}") from e
    return YAML_DEFAULTS.copy()


def config_set(config: dict[str, Any], parts: list[str], val: Any) -> None:
    config_walk(config, parts, "set", val)


def config_walk(
    config: dict[str, Any], parts: list[str], op: Literal["drop", "get", "set"], value: Any | None = None
) -> tuple[bool, Any | None]:
    match (op, parts):
        case ("get", [k, *tail]) if tail:
            return config_walk(config.get(k, {}), tail, op)
        case ("get", [k]):
            return (k in config), config.get(k)
        case ("set", [k, *tail]) if tail:
            child = config.setdefault(k, {})
            changed, _ = config_walk(child, tail, op, value)
            return changed, value
        case ("set", [k]):
            changed = config.get(k) != value
            config[k] = value
            return changed, value
        case ("drop", [k, *tail]) if tail:
            if (k not in config) or (not isinstance(config[k], dict)):
                return False, None
            changed, removed_value = config_walk(config[k], tail, op)
            if changed and not config[k]:
                config.pop(k)
            return changed, removed_value
        case ("drop", [k]):
            if k in config:
                removed_value = config.pop(k)
                return True, removed_value
            return False, None
    raise ValueError(f"Invalid operation: {op} with parts: {parts}")


def config_write(data: dict[str, Any]) -> None:
    data = {k: v for k, v in data.items() if not (isinstance(v, dict) and not v)}
    path = config_path()
    if not data:
        if path.exists():
            path.unlink()
        return
    tmp = path.with_suffix(".tmp")
    tmp.parent.mkdir(parents=True, exist_ok=True)
    tmp.write_text(
        strictyaml.as_document(data, YAML_SCHEMA).as_yaml(),
        encoding="utf-8",
    )
    os.replace(tmp, path)


def main() -> None:
    logging.basicConfig(level=logging.INFO, format="%(message)s")
    APP()


def releases_display(result: dict[str, Any]) -> None:
    if ("data" not in result) or ("count" not in result):
        LOGGER.error("Invalid response format")
        sys.exit(1)

    releases = result["data"]
    count = result["count"]

    if not releases:
        print("No releases found for this project.")
        return

    print(f"Total releases: {count}")
    print(f"  {'Version':<24} {'Phase':<11} {'Created'}")
    for release in releases:
        version = release.get("version", "Unknown")
        phase = release.get("phase", "Unknown")
        phase_short = {
            "release_candidate_draft": "draft",
            "release_candidate": "candidate",
            "release_preview": "preview",
            "release": "finished",
        }.get(phase, "unknown")
        created = release.get("created")
        created_formatted = timestamp_format(created) if created else "Unknown"
        print(f"  {version:<24} {phase_short:<11} {created_formatted}")


def test_app_release_list_not_found(
    capsys: pytest.CaptureFixture[str], monkeypatch: pytest.MonkeyPatch, tmp_path: pathlib.Path
) -> None:
    monkeypatch.setenv("ATR_CLIENT_CONFIG_PATH", str(tmp_path / "atr.yaml"))
    app_set("atr.host", "example.invalid")

    class Response:
        status = 404

        async def json(self):
            return {}

        async def text(self):
            return "Not Found"

        async def __aenter__(self):
            return self

        async def __aexit__(self, exc_type, exc, tb):
            return False

    class Session:
        async def __aenter__(self):
            return self

        async def __aexit__(self, exc_type, exc, tb):
            return False

        def get(self, *args, **kwargs):
            return Response()

    monkeypatch.setattr("aiohttp.ClientSession", lambda *a, **kw: Session())

    with pytest.raises(SystemExit):
        app_release_list("nonexistent-project")


def test_app_release_list_success(
    capsys: pytest.CaptureFixture[str], monkeypatch: pytest.MonkeyPatch, tmp_path: pathlib.Path
) -> None:
    monkeypatch.setenv("ATR_CLIENT_CONFIG_PATH", str(tmp_path / "atr.yaml"))
    app_set("atr.host", "example.invalid")

    class Response:
        status = 200

        async def json(self):
            return {
                "data": [
                    {"version": "2.3.1", "phase": "release_candidate_draft", "created": 1735689600},
                    {"version": "2.3.0", "phase": "release", "created": 1720051200},
                ],
                "count": 2,
            }

        async def text(self):
            return ""

        async def __aenter__(self):
            return self

        async def __aexit__(self, exc_type, exc, tb):
            return False

    class Session:
        async def __aenter__(self):
            return self

        async def __aexit__(self, exc_type, exc, tb):
            return False

        def get(self, *args, **kwargs):
            return Response()

    monkeypatch.setattr("aiohttp.ClientSession", lambda *a, **kw: Session())

    app_release_list("test-project")
    captured = capsys.readouterr()
    assert "Total releases: 2" in captured.out
    assert "2.3.1" in captured.out
    assert "2.3.0" in captured.out


def test_app_set_show(
    capsys: pytest.CaptureFixture[str], monkeypatch: pytest.MonkeyPatch, tmp_path: pathlib.Path
) -> None:
    monkeypatch.setenv("ATR_CLIENT_CONFIG_PATH", str(tmp_path / "atr.yaml"))
    app_set("atr.host", "example.invalid")
    app_show("atr.host")
    assert capsys.readouterr().out == "example.invalid\n"


def test_config_set_get_roundtrip() -> None:
    config: dict[str, Any] = {}
    config_set(config, ["abc", "pqr"], 123)
    assert config_get(config, ["abc", "pqr"]) == 123


def test_config_walk_drop() -> None:
    config: dict[str, Any] = {"a": {"b": 1}}
    changed, _ = config_walk(config, ["a", "b"], "drop")
    assert changed is True
    assert config == {}


def test_config_write_delete(monkeypatch: pytest.MonkeyPatch, tmp_path: pathlib.Path) -> None:
    config_path = tmp_path / "atr.yaml"
    monkeypatch.setenv("ATR_CLIENT_CONFIG_PATH", str(config_path))
    config_write({"atr": {"host": "example.invalid"}})
    assert config_path.exists() is True
    config_write({})
    assert config_path.exists() is False


def test_config_write_empty_dict_filter(monkeypatch: pytest.MonkeyPatch, tmp_path: pathlib.Path) -> None:
    monkeypatch.setenv("ATR_CLIENT_CONFIG_PATH", str(tmp_path / "atr.yaml"))
    config_write({"atr": {}, "asf": {"uid": ""}})
    config = config_read()
    assert "atr" not in config
    assert config_get(config, ["asf", "uid"]) == ""


def test_timestamp_format_epoch() -> None:
    assert timestamp_format(0) == "01 Jan 1970 at 00:00:00 UTC"


def test_timestamp_format_none_and_bad() -> None:
    assert timestamp_format(None) is None
    assert timestamp_format("bad") == "bad"


def test_web_fetch_failure(monkeypatch: pytest.MonkeyPatch) -> None:
    class Response:
        status = 500

        async def text(self):
            return "error"

        async def __aenter__(self):
            return self

        async def __aexit__(self, exc_type, exc, tb):
            return False

    class Session:
        async def __aenter__(self):
            return self

        async def __aexit__(self, exc_type, exc, tb):
            return False

        def post(self, *args, **kwargs):
            return Response()

    monkeypatch.setattr("aiohttp.ClientSession", lambda *a, **kw: Session())
    with pytest.raises(SystemExit):
        asyncio.run(web_fetch("https://error.invalid", "uid", "pat", verify_ssl=False))


def timestamp_format(ts: int | str | None) -> str | None:
    if ts is None:
        return None
    try:
        t = int(ts)
        dt = datetime.datetime.fromtimestamp(t, datetime.UTC)
        return dt.strftime("%d %b %Y at %H:%M:%S UTC")
    except Exception:
        return str(ts)


async def web_fetch(url: str, asfuid: str, pat_token: str, verify_ssl: bool = True) -> str:
    # TODO: This is PAT request specific
    # Should give this a more specific name
    connector = None if verify_ssl else aiohttp.TCPConnector(ssl=False)
    async with aiohttp.ClientSession(connector=connector) as session:
        payload = {"asfuid": asfuid, "pat": pat_token}
        async with session.post(url, json=payload) as resp:
            if resp.status != 200:
                text = await resp.text()
                LOGGER.error(f"JWT fetch failed: {resp.status} {text}")
                sys.exit(1)

            data: dict[str, Any] = await resp.json()
            if "jwt" in data:
                return data["jwt"]
            raise RuntimeError(f"Unexpected response: {data}")


async def web_get(url: str, jwt_token: str, verify_ssl: bool = True) -> Any:
    connector = None if verify_ssl else aiohttp.TCPConnector(ssl=False)
    headers = {"Authorization": f"Bearer {jwt_token}"}
    async with aiohttp.ClientSession(connector=connector, headers=headers) as session:
        async with session.get(url) as resp:
            if resp.status != 200:
                text = await resp.text()
                try:
                    error_data = json.loads(text)
                    if isinstance(error_data, dict) and "error" in error_data:
                        LOGGER.error(error_data["error"])
                    else:
                        LOGGER.error(f"Request failed: {resp.status} {text}")
                except json.JSONDecodeError:
                    LOGGER.error(f"Request failed: {resp.status} {text}")
                sys.exit(1)
            return await resp.json()


async def web_get_public(url: str, verify_ssl: bool = True) -> Any:
    connector = None if verify_ssl else aiohttp.TCPConnector(ssl=False)
    async with aiohttp.ClientSession(connector=connector) as session:
        async with session.get(url) as resp:
            if resp.status != 200:
                text = await resp.text()
                try:
                    error_data = json.loads(text)
                    if isinstance(error_data, dict) and "error" in error_data:
                        LOGGER.error(error_data["error"])
                    else:
                        LOGGER.error(f"Request failed: {resp.status} {text}")
                except json.JSONDecodeError:
                    LOGGER.error(f"Request failed: {resp.status} {text}")
                sys.exit(1)
            return await resp.json()


async def web_post(url: str, payload: dict[str, Any], jwt_token: str, verify_ssl: bool = True) -> Any:
    connector = None if verify_ssl else aiohttp.TCPConnector(ssl=False)
    headers = {"Authorization": f"Bearer {jwt_token}"}
    async with aiohttp.ClientSession(connector=connector, headers=headers) as session:
        async with session.post(url, json=payload) as resp:
            if resp.status not in (200, 201):
                text = await resp.text()
                LOGGER.error(f"Release add failed: {resp.status} {text}")
                sys.exit(1)

            try:
                return await resp.json()
            except Exception:
                text = await resp.text()
                return text


if __name__ == "__main__":
    main()
