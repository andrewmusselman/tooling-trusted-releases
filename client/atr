#!/usr/bin/env -S uv run --script

# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "aiohttp",
#     "cyclopts",
#     "filelock",
#     "platformdirs",
#     "pyjwt",
#     "strictyaml",
# ]
# [tool.uv]
# exclude-newer = "2025-07-04T13:08:00Z"
# ///

# Guide to contributors:
#
# - Use "import A", not "from A import ...", except for "from typing"
# - Group constants, types, and functions, then order alphabetically
# - Name functions in object oriented style, noun first and verb last
# - Do not use an underscore at the start of any interface names
# - Use list, | None, etc. in types
# - Use match and case, and the walrus operator
# - Never use "case _" with exhaustive types
# - Keep functions very short, and avoid indentation
# - Always group binary subexpressions in boolean expressions
# - Do not add any comments


from __future__ import annotations

import asyncio
import contextlib
import datetime
import json
import logging
import os
import pathlib
import sys
import tempfile
from typing import Any

import aiohttp  # type: ignore[import-not-found]
import cyclopts  # type: ignore[import-not-found]
import filelock  # type: ignore[import-not-found]
import jwt  # type: ignore[import-not-found]
import platformdirs  # type: ignore[import-not-found]
import strictyaml  # type: ignore[import-not-found]

APP: cyclopts.App = cyclopts.App()
CONFIG: cyclopts.App = cyclopts.App(name="config", help="Configuration operations.")
JWT: cyclopts.App = cyclopts.App(name="jwt", help="JWT operations.")
LOGGER = logging.getLogger(__name__)
PAT: cyclopts.App = cyclopts.App(name="pat", help="Personal Access Token operations.")
RELEASE: cyclopts.App = cyclopts.App(name="release", help="Release operations.")
YAML_DEFAULTS: dict[str, Any] = {"asf": {}, "atr": {}, "tokens": {}}
YAML_SCHEMA: strictyaml.Map = strictyaml.Map(
    {
        strictyaml.Optional("atr"): strictyaml.Map({strictyaml.Optional("host"): strictyaml.Str()}),
        strictyaml.Optional("asf"): strictyaml.Map({strictyaml.Optional("uid"): strictyaml.Str()}),
        strictyaml.Optional("tokens"): strictyaml.Map(
            {
                strictyaml.Optional("pat"): strictyaml.Str(),
                strictyaml.Optional("jwt"): strictyaml.Str(),
            }
        ),
    }
)

APP.command(CONFIG)
APP.command(JWT)
APP.command(PAT)
APP.command(RELEASE)


@CONFIG.command(name="file", help="Display the configuration file contents.")
def app_config_file() -> None:
    cfg = config_path()
    if not cfg.exists():
        LOGGER.error("No configuration file found.")
        sys.exit(1)

    with cfg.open("r", encoding="utf-8") as fh:
        for chunk in fh:
            print(chunk, end="")


@CONFIG.command(name="path", help="Show the configuration file path.")
def app_config_path() -> None:
    print(config_path())


@APP.command(name="drop", help="Remove a configuration key using dot notation.")
def app_drop(path: str) -> None:
    parts = path.split(".")
    if not parts:
        LOGGER.error("Not a valid configuration key")
        sys.exit(1)

    with config_lock():
        cfg = config_read()
        if not config_nested_drop(cfg, parts):
            LOGGER.error(f"Could not find {path} in the configuration file")
            sys.exit(1)
        config_write(cfg)

    LOGGER.info(f"Removed {path}.")


@PAT.command(name="drop", help="Remove the stored Personal Access Token.")
def app_pat_drop() -> None:
    with config_lock():
        cfg = config_read()
        if cfg.get("tokens", {}).pop("pat", None) is not None:
            if not cfg["tokens"]:
                cfg.pop("tokens")
            config_write(cfg)
            LOGGER.info("Personal Access Token removed.")
        else:
            LOGGER.error("No Personal Access Token stored.")
            sys.exit(1)


@JWT.command(name="dump", help="Show decoded JWT payload from stored config.")
def app_jwt_dump() -> None:
    with config_lock():
        cfg = config_read()
        jwt_token = cfg.get("tokens", {}).get("jwt")

    if jwt_token is None:
        LOGGER.error("No JWT stored in configuration.")
        sys.exit(1)

    try:
        payload = jwt.decode(jwt_token, options={"verify_signature": False})
    except jwt.PyJWTError as e:
        LOGGER.error(f"Failed to decode JWT: {e}")
        sys.exit(1)

    print(json.dumps(payload, indent=None))


@JWT.command(name="info", help="Show JWT payload in human-readable form.")
def app_jwt_info() -> None:
    with config_lock():
        cfg = config_read()
        token = cfg.get("tokens", {}).get("jwt")

    if token is None:
        LOGGER.error("No JWT stored in configuration.")
        sys.exit(1)

    try:
        payload = jwt.decode(token, options={"verify_signature": False})
    except jwt.PyJWTError as e:
        LOGGER.error(f"Failed to decode JWT: {e}")
        sys.exit(1)

    lines: list[str] = []
    for key, val in payload.items():
        if key in ("exp", "iat", "nbf"):
            val = timestamp_format(val)
        lines.append(f"{key.title()}: {val}")

    print("\n".join(lines))


@JWT.command(name="refresh", help="Fetch a JWT using the stored PAT and store it in config.")
def app_jwt_refresh(asf_uid: str | None = None) -> None:
    with config_lock():
        cfg = config_read()
        pat_token = cfg.get("tokens", {}).get("pat")

    if pat_token is None:
        LOGGER.error("No Personal Access Token stored.")
        sys.exit(1)

    host = cfg.get("atr", {}).get("host", "release-test.apache.org")
    url = f"https://{host}/api/jwt"

    if asf_uid is None:
        asf_uid = cfg.get("asf", {}).get("uid")

    if asf_uid is None:
        LOGGER.error("No ASF UID provided and asf.uid not configured.")
        sys.exit(1)

    verify_ssl = not host.startswith("127.0.0.1")
    jwt_token = asyncio.run(web_fetch(url, asf_uid, pat_token, verify_ssl))

    with config_lock():
        cfg = config_read()
        cfg.setdefault("tokens", {})
        cfg["tokens"]["jwt"] = jwt_token
        config_write(cfg)

    print(jwt_token)


@JWT.command(name="show", help="Show stored JWT token.")
def app_jwt_show() -> None:
    return app_show("tokens.jwt")


@RELEASE.command(name="start", help="Start a release.")
def app_release_start(project: str, version: str) -> None:
    with config_lock():
        cfg = config_read()
        jwt_token = cfg.get("tokens", {}).get("jwt")

    if jwt_token is None:
        LOGGER.error("No JWT stored in configuration.")
        sys.exit(1)

    host = cfg.get("atr", {}).get("host", "release-test.apache.org")
    url = f"https://{host}/api/releases/create"

    payload: dict[str, str] = {"project_name": project, "version": version}

    verify_ssl = not host.startswith("127.0.0.1")
    result = asyncio.run(web_post(url, payload, jwt_token, verify_ssl))
    print(result)


@APP.command(name="set", help="Set a configuration value using dot notation.")
def app_set(path: str, value: str) -> None:
    parts = path.split(".")
    if not parts:
        LOGGER.error("Not a valid configuration key.")
        sys.exit(1)

    with config_lock():
        cfg = config_read()
        config_nested_set(cfg, parts, value)
        config_write(cfg)

    LOGGER.info(f"Set {path} to {value}.")


@APP.command(name="show", help="Show a configuration value using dot notation.")
def app_show(path: str) -> None:
    parts = path.split(".")
    if not parts:
        LOGGER.error("Not a valid configuration key.")
        sys.exit(1)

    with config_lock():
        value = config_nested_get(config_read(), parts)

    if value is None:
        LOGGER.error(f"Could not find {path} in the configuration file.")
        sys.exit(1)

    print(value)


@contextlib.contextmanager
def config_lock():
    lock = filelock.FileLock(str(config_path()) + ".lock")
    with lock:
        yield


def config_nested_drop(cfg: dict[str, Any], parts: list[str]) -> bool:
    stack: list[tuple[dict[str, Any], str]] = []
    cur: dict[str, Any] = cfg
    for key in parts[:-1]:
        if key not in cur or not isinstance(cur[key], dict):
            return False
        stack.append((cur, key))
        cur = cur[key]
    if parts[-1] not in cur:
        return False
    cur.pop(parts[-1])
    while stack:
        parent, key = stack.pop()
        if not parent[key]:
            parent.pop(key)
    return True


def config_nested_get(cfg: dict[str, Any], parts: list[str]) -> Any | None:
    cur: Any = cfg
    for key in parts:
        if not isinstance(cur, dict) or key not in cur:
            return None
        cur = cur[key]
    return cur


def config_nested_set(cfg: dict[str, Any], parts: list[str], value: str) -> None:
    cur: dict[str, Any] = cfg
    for key in parts[:-1]:
        cur = cur.setdefault(key, {})
    cur[parts[-1]] = value


def config_path() -> pathlib.Path:
    return platformdirs.user_config_path("atr", appauthor="ASF") / "atr.yaml"


def config_read() -> dict[str, Any]:
    config_file = config_path()
    if config_file.exists():
        try:
            return strictyaml.load(config_file.read_text(), YAML_SCHEMA).data
        except strictyaml.YAMLValidationError as e:
            raise RuntimeError(f"Invalid atr.yaml: {e}") from e
    return YAML_DEFAULTS.copy()


def config_write(data: dict[str, Any]) -> None:
    config_file = config_path()

    if not any(bool(v) for v in data.values()):
        if config_file.exists():
            config_file.unlink()
        return

    config_file.parent.mkdir(parents=True, exist_ok=True)

    yaml_doc = strictyaml.as_document(data, YAML_SCHEMA)
    yaml_str = yaml_doc.as_yaml()

    with tempfile.NamedTemporaryFile("w", encoding="utf-8", dir=config_file.parent, delete=False) as tmp:
        tmp.write(yaml_str)
        tmp.flush()
        os.fsync(tmp.fileno())
        temp_path = pathlib.Path(tmp.name)

    os.replace(temp_path, config_file)


def main() -> None:
    logging.basicConfig(level=logging.INFO, format="%(message)s")
    APP()


def timestamp_format(ts: int | str | None) -> str | None:
    if ts is None:
        return None
    try:
        t = int(ts)
        dt = datetime.datetime.fromtimestamp(t, datetime.UTC)
        return dt.strftime("%d %b %Y at %H:%M:%S UTC")
    except Exception:
        return str(ts)


async def web_fetch(url: str, asfuid: str, pat_token: str, verify_ssl: bool = True) -> str:
    connector = aiohttp.TCPConnector(ssl=verify_ssl) if (not verify_ssl) else None
    async with aiohttp.ClientSession(connector=connector) as session:
        payload = {"asfuid": asfuid, "pat": pat_token}
        async with session.post(url, json=payload) as resp:
            if resp.status != 200:
                text = await resp.text()
                LOGGER.error(f"JWT fetch failed: {resp.status} {text}")
                sys.exit(1)

            data: dict[str, Any] = await resp.json()
            if "jwt" in data:
                return data["jwt"]
            raise RuntimeError(f"Unexpected response: {data}")


async def web_post(url: str, payload: dict[str, Any], jwt_token: str, verify_ssl: bool = True) -> Any:
    connector = aiohttp.TCPConnector(ssl=verify_ssl) if (not verify_ssl) else None
    headers = {"Authorization": f"Bearer {jwt_token}"}
    async with aiohttp.ClientSession(connector=connector, headers=headers) as session:
        async with session.post(url, json=payload) as resp:
            if resp.status not in (200, 201):
                text = await resp.text()
                LOGGER.error(f"Release add failed: {resp.status} {text}")
                sys.exit(1)

            try:
                return await resp.json()
            except Exception:
                text = await resp.text()
                return text


if __name__ == "__main__":
    main()
