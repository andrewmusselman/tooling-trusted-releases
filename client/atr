#!/usr/bin/env -S uv run --script

# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "aiohttp",
#     "cyclopts",
#     "filelock",
#     "platformdirs",
#     "strictyaml",
# ]
# [tool.uv]
# exclude-newer = "2025-07-04T13:08:00Z"
# ///

# Guide to contributors:
#
# - Use "import A", not "from A import ...", except for "from typing"
# - Group constants, types, and functions, then order alphabetically
# - Name functions in object oriented style, noun first and verb last
# - Use list, | None, etc. in types
# - Use match and case, and the walrus operator
# - Never use "case _" with exhaustive types
# - Keep functions very short, and avoid indentation
# - Always group binary subexpressions in boolean expressions
# - Do not add any comments


from __future__ import annotations

import asyncio
import contextlib
import logging
import os
import pathlib
import sys
import tempfile
from typing import Any, Literal

import aiohttp  # type: ignore[import-not-found]
import cyclopts  # type: ignore[import-not-found]
import filelock  # type: ignore[import-not-found]
import platformdirs  # type: ignore[import-not-found]
import strictyaml  # type: ignore[import-not-found]

APP: cyclopts.App = cyclopts.App()
CONFIG: cyclopts.App = cyclopts.App(name="config", help="Configuration operations.")
LOGGER = logging.getLogger(__name__)
PAT: cyclopts.App = cyclopts.App(name="pat", help="Personal Access Token operations.")
RELEASE: cyclopts.App = cyclopts.App(name="release", help="Release operations.")
YAML_DEFAULTS: dict[str, Any] = {"atr": {}, "tokens": {}}
YAML_SCHEMA: strictyaml.Map = strictyaml.Map(
    {
        strictyaml.Optional("atr"): strictyaml.Map({strictyaml.Optional("host"): strictyaml.Str()}),
        strictyaml.Optional("tokens"): strictyaml.Map({strictyaml.Optional("pat"): strictyaml.Str()}),
    }
)

APP.command(CONFIG)
APP.command(PAT)
APP.command(RELEASE)


@CONFIG.command(name="drop", help="Remove a configuration key from the atr section.")
def app_config_drop(key: Literal["host"]) -> None:
    with config_lock():
        cfg = config_read()

        atr_map = cfg.get("atr", {})
        if key in atr_map:
            atr_map.pop(key)
            if not atr_map:
                cfg.pop("atr")
        else:
            LOGGER.error(f"Key not found in atr: {key}")
            sys.exit(1)

        config_write(cfg)
        LOGGER.info(f"Configuration key removed: {key}")


@CONFIG.command(name="file", help="Display the configuration file contents.")
def app_config_file() -> None:
    cfg = config_path()
    if not cfg.exists():
        LOGGER.error("No configuration file found.")
        sys.exit(1)

    with cfg.open("r", encoding="utf-8") as fh:
        for chunk in fh:
            print(chunk, end="")


@CONFIG.command(name="path", help="Show the configuration file path.")
def app_config_path() -> None:
    print(config_path())


@CONFIG.command(name="set", help="Set a configuration key in the atr section.")
def app_config_set(key: Literal["host"], value: str) -> None:
    with config_lock():
        cfg = config_read()

        cfg.setdefault("atr", {})
        cfg["atr"][key] = value

        config_write(cfg)
        LOGGER.info(f"Configuration key set: {key}")


@CONFIG.command(name="show", help="Show a configuration value from the atr section.")
def app_config_show(key: Literal["host"]) -> None:
    with config_lock():
        value = config_read().get("atr", {}).get(key)

    if value is None:
        LOGGER.error(f"Key not found in atr: {key}")
        sys.exit(1)

    print(value)


@PAT.command(name="drop", help="Remove the stored Personal Access Token.")
def app_pat_drop() -> None:
    with config_lock():
        cfg = config_read()
        if cfg.get("tokens", {}).pop("pat", None) is not None:
            if not cfg["tokens"]:
                cfg.pop("tokens")
            config_write(cfg)
            LOGGER.info("Personal Access Token removed.")
        else:
            LOGGER.error("No Personal Access Token stored.")
            sys.exit(1)


@PAT.command(name="set", help="Set a Personal Access Token.")
def app_pat_set(token: str) -> None:
    with config_lock():
        cfg = config_read()
        cfg.setdefault("tokens", {})
        cfg["tokens"]["pat"] = token
        config_write(cfg)
    LOGGER.info("Personal Access Token stored.")


@PAT.command(name="show", help="Display the stored Personal Access Token.")
def app_pat_show() -> None:
    with config_lock():
        cfg = config_read()
        token = cfg.get("tokens", {}).get("pat")
    if token is not None:
        print(token)
    else:
        LOGGER.error("No Personal Access Token stored.")
        sys.exit(1)


@PAT.command(name="jwt", help="Fetch a JWT using the stored PAT.")
def app_pat_jwt(asf_uid: str | None = None) -> None:
    with config_lock():
        cfg = config_read()

    pat_token = cfg.get("tokens", {}).get("pat")
    if pat_token is None:
        LOGGER.error("No Personal Access Token stored.")
        sys.exit(1)

    host = cfg.get("atr", {}).get("host", "release-test.apache.org")
    url = f"https://{host}/api/jwt"

    if asf_uid is None:
        LOGGER.error("No ASF UID provided.")
        sys.exit(1)

    verify_ssl = not host.startswith("127.0.0.1")
    jwt = asyncio.run(web_fetch(url, asf_uid, pat_token, verify_ssl))
    print(jwt)


@RELEASE.command(name="add", help="Add a release.")
def app_release_add(project: str, version: str) -> None:
    print(project, version)
    raise NotImplementedError("Release add not implemented yet")


@contextlib.contextmanager
def config_lock():
    lock = filelock.FileLock(str(config_path()) + ".lock")
    with lock:
        yield


def config_path() -> pathlib.Path:
    return platformdirs.user_config_path("atr", appauthor="ASF") / "atr.yaml"


def config_read() -> dict[str, Any]:
    config_file = config_path()
    if config_file.exists():
        try:
            return strictyaml.load(config_file.read_text(), YAML_SCHEMA).data
        except strictyaml.YAMLValidationError as exc:
            raise RuntimeError(f"Invalid atr.yaml: {exc}") from exc
    return YAML_DEFAULTS.copy()


def config_write(data: dict[str, Any]) -> None:
    config_file = config_path()

    if not any(bool(v) for v in data.values()):
        if config_file.exists():
            config_file.unlink()
        return

    config_file.parent.mkdir(parents=True, exist_ok=True)

    yaml_doc = strictyaml.as_document(data, YAML_SCHEMA)
    yaml_str = yaml_doc.as_yaml()

    with tempfile.NamedTemporaryFile("w", encoding="utf-8", dir=config_file.parent, delete=False) as tmp:
        tmp.write(yaml_str)
        tmp.flush()
        os.fsync(tmp.fileno())
        temp_path = pathlib.Path(tmp.name)

    os.replace(temp_path, config_file)


def main() -> None:
    logging.basicConfig(level=logging.INFO, format="%(message)s")
    APP()


async def web_fetch(url: str, asfuid: str, pat_token: str, verify_ssl: bool = True) -> str:
    connector = aiohttp.TCPConnector(ssl=verify_ssl) if not verify_ssl else None
    async with aiohttp.ClientSession(connector=connector) as session:
        payload = {"asfuid": asfuid, "pat": pat_token}
        async with session.post(url, json=payload) as resp:
            if resp.status != 200:
                text = await resp.text()
                LOGGER.error(f"JWT fetch failed: {resp.status} {text}")
                sys.exit(1)

            data: dict[str, Any] = await resp.json()
            if "jwt" in data:
                return data["jwt"]
            raise RuntimeError(f"Unexpected response: {data}")


if __name__ == "__main__":
    main()
