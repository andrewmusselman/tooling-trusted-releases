#!/usr/bin/env -S uv run --script

# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "aiohttp",
#     "cyclopts",
#     "filelock",
#     "platformdirs",
#     "pyjwt",
#     "pytest>=8.4.1",
#     "strictyaml",
# ]
# [tool.uv]
# exclude-newer = "2025-07-04T19:04:51Z"
# ///

# Guide to contributors:
#
# - Use "import A", not "from A import ...", except for "from typing"
# - Group constants, types, and functions, then order alphabetically
# - Name functions in object oriented style, noun first and verb last
# - Do not use an underscore at the start of any interface names
# - Use list, | None, etc. in types
# - Use match and case, and the walrus operator
# - Never use "case _" with exhaustive types
# - Keep functions very short, and avoid indentation
# - Always group binary subexpressions in boolean expressions
# - Do not add any comments


from __future__ import annotations

import asyncio
import contextlib
import datetime
import json
import logging
import os
import pathlib
import re
import subprocess
import sys
import tempfile
from typing import TYPE_CHECKING, Annotated, Any, Literal

import aiohttp  # type: ignore[import-not-found]
import cyclopts  # type: ignore[import-not-found]
import filelock  # type: ignore[import-not-found]
import jwt  # type: ignore[import-not-found]
import platformdirs  # type: ignore[import-not-found]
import strictyaml  # type: ignore[import-not-found]

if TYPE_CHECKING:
    from collections.abc import Generator

APP: cyclopts.App = cyclopts.App()
CONFIG: cyclopts.App = cyclopts.App(name="config", help="Configuration operations.")
DEV: cyclopts.App = cyclopts.App(name="dev", help="Developer operations.")
JWT: cyclopts.App = cyclopts.App(name="jwt", help="JWT operations.")
LOGGER = logging.getLogger(__name__)
RELEASE: cyclopts.App = cyclopts.App(name="release", help="Release operations.")
YAML_DEFAULTS: dict[str, Any] = {"asf": {}, "atr": {}, "tokens": {}}
YAML_SCHEMA: strictyaml.Map = strictyaml.Map(
    {
        strictyaml.Optional("atr"): strictyaml.Map({strictyaml.Optional("host"): strictyaml.Str()}),
        strictyaml.Optional("asf"): strictyaml.Map({strictyaml.Optional("uid"): strictyaml.Str()}),
        strictyaml.Optional("tokens"): strictyaml.Map(
            {
                strictyaml.Optional("pat"): strictyaml.Str(),
                strictyaml.Optional("jwt"): strictyaml.Str(),
            }
        ),
    }
)

APP.command(CONFIG)
APP.command(DEV)
APP.command(JWT)
APP.command(RELEASE)


@CONFIG.command(name="file", help="Display the configuration file contents.")
def app_config_file() -> None:
    path = config_path()
    if not path.exists():
        LOGGER.error("No configuration file found.")
        sys.exit(1)

    with path.open("r", encoding="utf-8") as fh:
        for chunk in fh:
            print(chunk, end="")


@CONFIG.command(name="path", help="Show the configuration file path.")
def app_config_path() -> None:
    print(config_path())


@DEV.command(name="lock", help="Regenerate uv lockfile.")
def app_dev_lock() -> None:
    subprocess.check_call(["uv", "lock", "--script", str(pathlib.Path(__file__))])


@DEV.command(name="stamp", help="Update date stamp in header.")
def app_dev_stamp() -> None:
    path = pathlib.Path(__file__)
    text = path.read_text()
    ts = datetime.datetime.now(datetime.UTC).strftime("%Y-%m-%dT%H:%M:%SZ")
    new_text = re.sub(r"\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z", ts, text)
    if text == new_text:
        LOGGER.info("No stamp updated.")
        return
    path.write_text(new_text, "utf-8")
    LOGGER.info(f"Stamp updated to {ts}.")


@APP.command(name="drop", help="Remove a configuration key using dot notation.")
def app_drop(path: str) -> None:
    parts = path.split(".")
    if not parts:
        LOGGER.error("Not a valid configuration key")
        sys.exit(1)

    with config_lock(write=True) as config:
        present, _ = config_walk(config, parts, "drop")
        if not present:
            LOGGER.error(f"Could not find {path} in the configuration file")
            sys.exit(1)

    LOGGER.info(f"Removed {path}.")


@JWT.command(name="dump", help="Show decoded JWT payload from stored config.")
def app_jwt_dump() -> None:
    with config_lock() as config:
        jwt_value = config_get(config, ["tokens", "jwt"])

    if jwt_value is None:
        LOGGER.error("No JWT stored in configuration.")
        sys.exit(1)

    header = jwt.get_unverified_header(jwt_value)
    if header != {"alg": "HS256", "typ": "JWT"}:
        LOGGER.error("Invalid JWT header.")
        sys.exit(1)

    try:
        payload = jwt.decode(jwt_value, options={"verify_signature": False})
    except jwt.PyJWTError as e:
        LOGGER.error(f"Failed to decode JWT: {e}")
        sys.exit(1)

    print(json.dumps(payload, indent=None))


@JWT.command(name="info", help="Show JWT payload in human-readable form.")
def app_jwt_info() -> None:
    with config_lock() as config:
        jwt_value = config_get(config, ["tokens", "jwt"])

    if jwt_value is None:
        LOGGER.error("No JWT stored in configuration.")
        sys.exit(1)

    try:
        payload = jwt.decode(jwt_value, options={"verify_signature": False})
    except jwt.PyJWTError as e:
        LOGGER.error(f"Failed to decode JWT: {e}")
        sys.exit(1)

    lines: list[str] = []
    for key, val in payload.items():
        if key in ("exp", "iat", "nbf"):
            val = timestamp_format(val)
        lines.append(f"{key.title()}: {val}")

    print("\n".join(lines))


@JWT.command(name="refresh", help="Fetch a JWT using the stored PAT and store it in config.")
def app_jwt_refresh(asf_uid: str | None = None) -> None:
    with config_lock() as config:
        pat_value = config_get(config, ["tokens", "pat"])

    if pat_value is None:
        LOGGER.error("No Personal Access Token stored.")
        sys.exit(1)

    host = config.get("atr", {}).get("host", "release-test.apache.org")
    url = f"https://{host}/api/jwt"

    if asf_uid is None:
        asf_uid = config.get("asf", {}).get("uid")

    if asf_uid is None:
        LOGGER.error("No ASF UID provided and asf.uid not configured.")
        sys.exit(1)

    verify_ssl = not host.startswith("127.0.0.1")
    jwt_token = asyncio.run(web_fetch(url, asf_uid, pat_value, verify_ssl))

    with config_lock(write=True) as config:
        config_set(config, ["tokens", "jwt"], jwt_token)

    print(jwt_token)


@JWT.command(name="show", help="Show stored JWT token.")
def app_jwt_show() -> None:
    return app_show("tokens.jwt")


@RELEASE.command(name="start", help="Start a release.")
def app_release_start(project: str, version: str) -> None:
    with config_lock() as config:
        jwt_value = config_get(config, ["tokens", "jwt"])

    if jwt_value is None:
        LOGGER.error("No JWT stored in configuration.")
        sys.exit(1)

    host = config.get("atr", {}).get("host", "release-test.apache.org")
    url = f"https://{host}/api/releases/create"

    payload: dict[str, str] = {"project_name": project, "version": version}

    verify_ssl = not host.startswith("127.0.0.1")
    result = asyncio.run(web_post(url, payload, jwt_value, verify_ssl))
    print(result)


@APP.command(name="set", help="Set a configuration value using dot notation.")
def app_set(path: str, value: str) -> None:
    parts = path.split(".")
    if not parts:
        LOGGER.error("Not a valid configuration key.")
        sys.exit(1)

    with config_lock(write=True) as config:
        config_set(config, path.split("."), value)

    LOGGER.info(f"Set {path} to {value}.")


@APP.command(name="show", help="Show a configuration value using dot notation.")
def app_show(path: str) -> None:
    parts = path.split(".")
    if not parts:
        LOGGER.error("Not a valid configuration key.")
        sys.exit(1)

    with config_lock() as config:
        value = config_get(config, parts)

    if value is None:
        LOGGER.error(f"Could not find {path} in the configuration file.")
        sys.exit(1)

    print(value)


@APP.command(name="test", help="Run tests.")
def app_test(q: Annotated[bool, cyclopts.Parameter(alias="-q")] = False, *pytest_args: str) -> None:
    import pytest

    cwd = os.getcwd()
    with tempfile.TemporaryDirectory() as td:
        p = pathlib.Path(td, "atr_api_client.py")
        p.write_bytes(pathlib.Path(__file__).read_bytes())
        os.chdir(td)
        prev = os.environ.get("ATR_CLIENT_CONFIG_PATH")
        os.environ["ATR_CLIENT_CONFIG_PATH"] = str(pathlib.Path(td, "atr_test.yaml"))
        try:
            args = (["-q"] if q else []) + list(pytest_args) + [str(p)]
            sys.exit(pytest.main(args))
        finally:
            if prev is None:
                os.environ.pop("ATR_CLIENT_CONFIG_PATH", None)
            else:
                os.environ["ATR_CLIENT_CONFIG_PATH"] = prev
            os.chdir(cwd)


def config_drop(cfg: dict[str, Any], parts: list[str]) -> None:
    config_walk(cfg, parts, "drop")


def config_get(cfg: dict[str, Any], parts: list[str]) -> Any | None:
    return config_walk(cfg, parts, "get")[1]


@contextlib.contextmanager
def config_lock(write: bool = False) -> Generator[dict[str, Any]]:
    lock = filelock.FileLock(str(config_path()) + ".lock")
    with lock:
        config = config_read()
        yield config
        if write is True:
            config_write(config)


def config_path() -> pathlib.Path:
    if env := os.getenv("ATR_CLIENT_CONFIG_PATH"):
        return pathlib.Path(env).expanduser()
    return platformdirs.user_config_path("atr", appauthor="ASF") / "atr.yaml"


def config_read() -> dict[str, Any]:
    config_file = config_path()
    if config_file.exists():
        try:
            return strictyaml.load(config_file.read_text(), YAML_SCHEMA).data
        except strictyaml.YAMLValidationError as e:
            raise RuntimeError(f"Invalid atr.yaml: {e}") from e
    return YAML_DEFAULTS.copy()


def config_set(cfg: dict[str, Any], parts: list[str], val: Any) -> None:
    config_walk(cfg, parts, "set", val)


def config_walk(
    config: dict[str, Any], parts: list[str], op: Literal["drop", "get", "set"], value: Any | None = None
) -> tuple[bool, Any | None]:
    match (op, parts):
        case ("get", [k, *tail]) if tail:
            return config_walk(config.get(k, {}), tail, op)
        case ("get", [k]):
            return (k in config), config.get(k)
        case ("set", [k, *tail]) if tail:
            child = config.setdefault(k, {})
            changed, _ = config_walk(child, tail, op, value)
            return changed, value
        case ("set", [k]):
            changed = config.get(k) != value
            config[k] = value
            return changed, value
        case ("drop", [k, *tail]) if tail:
            if (k not in config) or (not isinstance(config[k], dict)):
                return False, None
            changed, removed_value = config_walk(config[k], tail, op)
            if changed and not config[k]:
                config.pop(k)
            return changed, removed_value
        case ("drop", [k]):
            if k in config:
                removed_value = config.pop(k)
                return True, removed_value
            return False, None
    raise ValueError(f"Invalid operation: {op} with parts: {parts}")


def config_write(data: dict[str, Any]) -> None:
    path = config_path()
    if not any(data.values()):
        if path.exists():
            path.unlink()
        return
    tmp = path.with_suffix(".tmp")
    tmp.parent.mkdir(parents=True, exist_ok=True)
    tmp.write_text(strictyaml.as_document(data, YAML_SCHEMA).as_yaml(), "utf-8")
    os.replace(tmp, path)


def main() -> None:
    logging.basicConfig(level=logging.INFO, format="%(message)s")
    APP()


def test_config_set_get_roundtrip() -> None:
    config: dict[str, object] = {}
    config_set(config, ["abc", "pqr"], 123)
    assert config_get(config, ["abc", "pqr"]) == 123


def test_timestamp_format_epoch() -> None:
    assert timestamp_format(0) == "01 Jan 1970 at 00:00:00 UTC"


def timestamp_format(ts: int | str | None) -> str | None:
    if ts is None:
        return None
    try:
        t = int(ts)
        dt = datetime.datetime.fromtimestamp(t, datetime.UTC)
        return dt.strftime("%d %b %Y at %H:%M:%S UTC")
    except Exception:
        return str(ts)


async def web_fetch(url: str, asfuid: str, pat_token: str, verify_ssl: bool = True) -> str:
    connector = None if verify_ssl else aiohttp.TCPConnector(ssl=False)
    async with aiohttp.ClientSession(connector=connector) as session:
        payload = {"asfuid": asfuid, "pat": pat_token}
        async with session.post(url, json=payload) as resp:
            if resp.status != 200:
                text = await resp.text()
                LOGGER.error(f"JWT fetch failed: {resp.status} {text}")
                sys.exit(1)

            data: dict[str, Any] = await resp.json()
            if "jwt" in data:
                return data["jwt"]
            raise RuntimeError(f"Unexpected response: {data}")


async def web_post(url: str, payload: dict[str, Any], jwt_token: str, verify_ssl: bool = True) -> Any:
    connector = None if verify_ssl else aiohttp.TCPConnector(ssl=False)
    headers = {"Authorization": f"Bearer {jwt_token}"}
    async with aiohttp.ClientSession(connector=connector, headers=headers) as session:
        async with session.post(url, json=payload) as resp:
            if resp.status not in (200, 201):
                text = await resp.text()
                LOGGER.error(f"Release add failed: {resp.status} {text}")
                sys.exit(1)

            try:
                return await resp.json()
            except Exception:
                text = await resp.text()
                return text


if __name__ == "__main__":
    main()
