<h1>Project conventions</h1>
<h2>Python functions</h2>
<h3>Name functions in a collation friendly way</h3>
<p>Functions should be named hierarchically, with the most general category first, followed by increasingly specific details. This makes related functions group together naturally when sorted alphabetically, making code navigation and discovery easier.</p>
<p><strong>Example</strong>:</p>
<p>Instead of scattered, hard to find related functions:</p>
<pre><code class="language-python">def get_user_from_db():
def insert_new_record():
def query_user_settings():
def update_db_record():
</code></pre>
<p>Use hierarchical naming that groups related functionality:</p>
<pre><code class="language-python">def db_user_get():
def db_record_insert():
def db_user_settings_query():
def db_record_update():
</code></pre>
<p><strong>Example</strong>:</p>
<p>Another example with license files, the wrong way:</p>
<pre><code class="language-python">def check_root_license_file():      # Lost among other &quot;check_&quot; functions
def validate_package_license():     # Separated from other license functions
def verify_license_files():         # Yet another scattered license function
</code></pre>
<p>The right way:</p>
<pre><code class="language-python">def license_root_file_check():      # All license-related functions
def license_package_validate():     # will appear together when
def license_files_verify():         # sorted alphabetically
</code></pre>
<p>Note how verbs tend to come last, so that function names now read in an object oriented style, with a module, object, and action.</p>
<p>While this approach can lead to slightly longer function names, the benefits of improved code organisation and discoverability outweigh the verbosity.</p>
<h3>Give helper functions the same prefix as their parent function</h3>
<p>This makes it easier to find all the functions related to a specific task.</p>
<p><strong>Example</strong>:</p>
<p>Instead of:</p>
<pre><code class="language-python">def verify_archive_integrity():
def do_something_in_verify_archive_integrity():
</code></pre>
<p>Use the same prefix:</p>
<pre><code class="language-python">def verify_archive_integrity():
def verify_archive_integrity_do_something():
</code></pre>
<p>This makes it easier to find all the functions related to a specific task, and means that they sort together.</p>
<h3>Keep cyclomatic complexity below 10</h3>
<p>We limit function complexity to a score of 10. If the linter complains, your function is doing too much.</p>
<p>Cyclomatic complexity counts the number of independent paths through code: more if/else branches, loops, and exception handlers means higher complexity. Complex code is harder to test, maintain, and understand. The easiest way to fix high complexity is usually to refactor a chunk of related logic into a separate helper function.</p>
<h3>Use parentheses to group subexpressions in boolean expressions always</h3>
<p>Instead of this:</p>
<pre><code class="language-python">a or b and c == d or e
</code></pre>
<p>Do:</p>
<pre><code class="language-python">(a or b) and (c == d) or e
</code></pre>
<h2>HTML</h2>
<h3>Use sentence case for headings</h3>
<p>We write headings like &quot;This is a heading&quot;, and not &quot;This is a Heading&quot; or &quot;This Is A Heading&quot;. This follows the <a href="https://en.wikipedia.org/wiki/Wikipedia:Manual_of_Style#Section_headings">Wikipedia style for headings</a>. The same goes for button texts.</p>
