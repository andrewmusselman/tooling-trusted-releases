<h1 id="outcome-design-patterns">Outcome design patterns</h1>
<p>One common pattern when designing outcome types is about how to handle an <strong>exception after a success</strong>, and how to handle a <strong>warning during success</strong>:</p>
<ul>
<li>An <strong>exception after a success</strong> is when an object is processed in multiple stages, and the first few stages succeed but then subsequently there is an exception.</li>
<li>A <strong>warning during success</strong> is when an object is processed in multiple stages, an exception is raised, but we determine that we can proceed to subsequent stages as long as we keep a note of the exception.</li>
</ul>
<p>Both of these workflows appear incompatible with outcomes. In outcomes, we can record <em>either</em> a successful result, <em>or</em> an exception. But in exception after success we want to record the successes up to the exception; and in a warning during a success we want to record the exception even though we return a success result.</p>
<p>The solution is similar in both cases: create a wrapper of the <em>primary type</em> which can hold an instance of the <em>secondary type</em>.</p>
<p>In <em>exception after a success</em> the primary type is an exception, and the secondary type is the result which was obtained up to that exception. The type will look like this:</p>
<pre><code class="language-python">class AfterSuccessError(Exception):
    def __init__(self, result_before_error: Result):
        self.result_before_error = result_before_error
</code></pre>
<p>In <em>warning during success</em>, the primary type is the result, and the secondary type is the exception raised during successful processing which we consider a warning. This is the inverse of the above, and the types are therefore inverted too.</p>
<pre><code class="language-python">@dataclasses.dataclass
class Result:
    value: Value
    warning: Exception | None
</code></pre>
<p>This could just as easily be a Pydantic class or whatever is appropriate in the situation, as long as it can hold the warning. If the warning is generated during an additional or side task, we can use <code>Outcome[SideValue]</code> instead. We do this, for example, in the type representing a linked committee:</p>
<pre><code class="language-python">@dataclasses.dataclass
class LinkedCommittee:
    name: str
    autogenerated_keys_file: Outcome[str]
</code></pre>
<p>In this case, if the autogenerated keys file call succeeded without an error, the <code>Outcome</code> will be an <code>OutcomeResult[str]</code> where the <code>str</code> represents the full path to the autogenerated file.</p>
