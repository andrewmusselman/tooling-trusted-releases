# Outcome design patterns

One common pattern when designing outcome types is about how to handle an **exception after a success**, and how to handle a **warning during success**:

* An **exception after a success** is when an object is processed in multiple stages, and the first few stages succeed but then subsequently there is an exception.
* A **warning during success** is when an object is processed in multiple stages, an exception is raised, but we determine that we can proceed to subsequent stages as long as we keep a note of the exception.

Both of these workflows appear incompatible with outcomes. In outcomes, we can record _either_ a successful result, _or_ an exception. But in exception after success we want to record the successes up to the exception; and in a warning during a success we want to record the exception even though we return a success result.

The solution is similar in both cases: create a wrapper of the _primary type_ which can hold an instance of the _secondary type_.

In _exception after a success_ the primary type is an exception, and the secondary type is the result which was obtained up to that exception. The type will look like this:

```python
class AfterSuccessError(Exception):
    def __init__(self, result_before_error: Result):
        self.result_before_error = result_before_error
```

In _warning during success_, the primary type is the result, and the secondary type is the exception raised during successful processing which we consider a warning. This is the inverse of the above, and the types are therefore inverted too.

```python
@dataclasses.dataclass
class Result:
    value: Value
    warning: Exception | None
```

This could just as easily be a Pydantic class or whatever is appropriate in the situation, as long as it can hold the warning. If the warning is generated during an additional or side task, we can use `Outcome[SideValue]` instead. We do this, for example, in the type representing a linked committee:

```python
@dataclasses.dataclass
class LinkedCommittee:
    name: str
    autogenerated_keys_file: Outcome[str]
```

In this case, if the autogenerated keys file call succeeded without an error, the `Outcome` will be an `OutcomeResult[str]` where the `str` represents the full path to the autogenerated file.
